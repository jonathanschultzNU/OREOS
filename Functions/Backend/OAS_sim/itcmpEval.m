function [ fitResult ] = itcmpEval( params, n, varargin )
%ITCMPEVAL Evaluate ITCMP fit
%	Evaluates a fit generated by itcmp on the same grid of n time points
%	from the modelled data.
%
% [fitResult] = itcmpEval(params, n, [NAME, VALUE])
%
% INPUT
%	params			(real) Output parameters from itcmp with columns for
%					damping rate, frequency, amplitude, and phase
%	n				(real) number of time series points in the data 
%					modelled by itcmp
%	*components		(char) Which components of the fit to include in
%					the evaluated model.  Valid options include:
%						'all' (all exponentials)
%						'osc' (only "oscillatory" exponentials)
%						'nonOsc' (only "non-oscillatory" exponentials)
%					Default: 'all'
%	*oscThreshold	(real) Threshold for defining which components are 
%					oscillatory.  If the exponential damping rate is less
%					than oscThresh times the frequency, it is considered an
%					oscillation.
%					Default: 5
%	noOsc			(logical) Deprecated.  Use 'components' instead.
%
% * indicates optional name-value ('key', value) input parameter
%
% OUTPUT
%	fitResult	(double) Vector of time series data points evaluated from
%				the itcmp parameters in params.  length(fitResult) = n
%
%	See also itcmp, itcmpFilterOscillations, itcmpParamConversion.
%

%	Author: Austin P. Spencer
%	Email: austin.spencer (at) northwestern.edu
%	Last revision date: April 5, 2019
%
%	Copyright: Austin P. Spencer, 2019

	% Parse function inputs
	ip = inputParser;
	ip.addRequired('params', @isreal);
	ip.addRequired('n', @isreal);
	ip.addParameter('components', 'all', @(x) any(validatestring(x, ...
		{'all', 'both', 'full', 'osc', 'AC', 'nonOsc','noOsc', 'DC'}))); %,'lowosc','highosc'
	ip.addParameter('oscThresh', 5, @isreal);
	ip.addParameter('noOsc', false, @islogical);	% (for compatibility)
	ip.parse(params, n, varargin{:});
	inputs = ip.Results;
	
	% Override "components" input if "noOsc" is specified. (for backwards
	% compatibility)
	if ~any(strcmpi(ip.UsingDefaults, 'noOsc'))
		if inputs.noOsc
			inputs.components = 'nonOsc';
		else
			inputs.components = 'both';
		end
	end
	
	if ~isscalar(n)
		n = length(n);
	end
	
	% Filter out oscillatory/non-oscillatory components if requested.
	switch inputs.components
		case {'nonOsc', 'noOsc', 'DC'}	% Non-oscillating components
			[params, ~] = itcmpFilterOscillations(params, n, ...
				'oscThresh', inputs.oscThresh);
		case {'osc', 'AC'}				% Oscillating components
			[params, ~] = itcmpFilterOscillations(params, n, ...
				'oscThresh', inputs.oscThresh);
%         case {'highosc'}				% Oscillating components
% 			[~, ~, params, ~] = itcmpFilterOscillations(params, n, ...
% 				'oscThresh', inputs.oscThresh);
%         case {'lowosc'}				% Oscillating components
% 			[~, ~, ~, params] = itcmpFilterOscillations(params, n, ...
% 				'oscThresh', inputs.oscThresh);
            
		case {'both', 'all', 'full'}	% All components
			
	end
	
	% Functional form: A*exp(-rate*t + 1i*2*pi*f*t + 1i*phi)
	A = params(:,3);		% Amplitude
	rate = params(:,1);		% Damping rate
	f = params(:,2);		% Frequency
	phi = params(:,4);		% Phase
	
	% Create time series axis
	t = (1:1:n)-1;

	% Evaluate the fit
	fitResult = sum(bsxfun(@times, A, ...
		exp(-bsxfun(@times, t, rate)...
			+ 1i*bsxfun(@times, t, 2*pi*f)...
			+ 1i*bsxfun(@times, ones(size(t)), phi))...
		), 1);

end

